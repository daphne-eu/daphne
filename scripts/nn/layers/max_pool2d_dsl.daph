#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
# Modifications Copyright 2024 The DAPHNE Consortium
#
#-------------------------------------------------------------

# This script has been manually translated from Apache SystemDS.

/*
 * Max Pooling layer.
 */

import "../util.daph" as "util";

#forward = function(matrix[double] X, int C, int Hin, int Win, int Hf, int Wf,
#                   int strideh, int stridew, int padh, int padw)
def forward(X:matrix, C, Hin, Win, Hf, Wf, strideh, stridew, padh, padw) -> matrix, si64, si64 {
#    return (matrix[double] out, int Hout, int Wout) {
  /*
   * Computes the forward pass for a 2D spatial max pooling layer.
   * The input data has N examples, each represented as a 3D volume
   * unrolled into a single vector.
   *
   * This implementation uses `im2col` internally for each image to
   * extract local image regions (patches) of each channel slice into
   * columns, and then performs max pooling over the patches to compute
   * the output maps.
   *
   * Inputs:
   *  - X: Inputs, of shape (N, C*Hin*Win).
   *  - C: Number of input channels (dimensionality of input depth).
   *  - Hin: Input height.
   *  - Win: Input width.
   *  - Hf: Filter height.
   *  - Wf: Filter width.
   *  - strideh: Stride over height.
   *  - stridew: Stride over width.
   *  - padh: Padding for top and bottom sides.
   *      A typical value is 0.
   *  - padw: Padding for left and right sides.
   *      A typical value is 0.
   *
   * Outputs:
   *  - out: Outputs, of shape (N, C*Hout*Wout).
   *  - Hout: Output height.
   *  - Wout: Output width.
   */
  N = nrow(X);
  Hout = floor((Hin + 2*padh - Hf)/strideh + 1);
  Wout = floor((Win + 2*padw - Wf)/stridew + 1);
  pad_value = -1.0/0.0;  # in max pooling we pad with -infinity;

  # Create output volume
  #out = matrix(0, rows=N, cols=C*Hout*Wout)
out = fill(0.0, N, C * Hout * Wout);

  # Max pooling - im2col implementation
  for (n in 0:N - 1) {  # all examples
    img = reshape(X[n,], C, Hin * Win);  # reshape

    if (padh > 0 || padw > 0) {
      # Pad image to shape (C, (Hin+2*padh)*(Win+2*padw))
      img = util.pad_image(img, Hin, Win, padh, padw, pad_value);
    }

    img_maxes = fill(0.0, C, Hout * Wout);  # zeros
    for (c in 0:C - 1) {  # all channels
      # Extract local image slice patches into columns with im2col, of shape (Hf*Wf, Hout*Wout)
      img_slice_cols = util.im2col(img[c,], Hin + 2 * padh, Win + 2 * padw, Hf, Wf, strideh, stridew);

      # Max pooling on patches
      img_maxes[c,] = aggMax(img_slice_cols, 1);
    }

    out[n,] = reshape(img_maxes, 1, C * Hout * Wout);
  }
  return out, as.si64(Hout), as.si64(Wout);
}

#backward = function(matrix[double] dout, int Hout, int Wout, matrix[double] X,
#                    int C, int Hin, int Win, int Hf, int Wf,
#                    int strideh, int stridew, int padh, int padw)
#    return (matrix[double] dX) {
def backward(dout:matrix, Hout, Wout, X:matrix, C, Hin, Win, Hf, Wf, strideh, stridew, padh, padw)
        -> matrix {
  /*
   * Computes the backward pass for a 2D spatial max pooling layer.
   * The input data has N examples, each represented as a 3D volume
   * unrolled into a single vector.
   *
   * Inputs:
   *  - dout: Gradient wrt `out` from upstream, of
   *      shape (N, C*Hout*Wout).
   *  - Hout: Output height.
   *  - Wout: Output width.
   *  - X: Input data matrix, of shape (N, C*Hin*Win).
   *  - C: Number of input channels (dimensionality of input depth).
   *  - Hin: Input height.
   *  - Win: Input width.
   *  - Hf: Filter height.
   *  - Wf: Filter width.
   *  - strideh: Stride over height.
   *  - stridew: Stride over width.
   *  - padh: Padding for top and bottom sides.
   *      A typical value is 0.
   *  - padw: Padding for left and right sides.
   *      A typical value is 0.
   *
   * Outputs:
   *  - dX: Gradient wrt `X`, of shape (N, C*Hin*Win).
   */
  N = nrow(X);
  pad_value = -1.0/0.0;  # in max pooling we pad with -infinity

#  # Create gradient volume
  dX = fill(0.0, N, C * Hin * Win);

  # Gradient of max pooling
  for (n in 0:N - 1) {  # all examples
    img = reshape(X[n,], C, Hin * Win);
    if (padh > 0 || padw > 0) {
      # Pad image to shape (C, (Hin+2*padh)*(Win+2*padw))
      img = util.pad_image(img, Hin, Win, padh, padw, pad_value);
    }

    dimg = fill(0.0, C, (Hin + 2 * padh) * (Win + 2 * padw));
    for (c in 0:C - 1) {  # all channels
    #print("c:" + c);
      img_slice = reshape(img[c,], Hin + 2 * padh, Win + 2 * padw);
      dimg_slice = fill(0.0, Hin + 2 * padh, Win + 2 * padw);
      for (hout in 0:Hout - 1) {  # all output rows
        hin_ = hout * strideh;
        for (wout in 0:Wout - 1) {  # all output columns
          win_ = wout * stridew;
          #print("win_: " + win_);
          img_slice_patch = img_slice[hin_:hin_ + Hf - 1, win_:win_ + Wf - 1];
          max_val_ind = img_slice_patch == aggMax(img_slice_patch);  # max value indicator matrix
          #print("max_val_ind: ");
          #print(max_val_ind);
          # gradient passes through only for the max value(s) in this patch
          dimg_slice_patch = max_val_ind * dout[n, c * Hout * Wout + hout * Wout + wout];
          dimg_slice[hin_:hin_ + Hf - 1, win_:win_ + Wf - 1] = dimg_slice[hin_:hin_ + Hf - 1, win_:win_ + Wf - 1] + dimg_slice_patch;
     #     print(dimg_slice_patch);
          #print(dimg_slice);
          #print("win_ + Wf: " + (win_ + Wf));
        }
      }
      dimg[c,] = reshape(dimg_slice, 1, (Hin + 2 * padh) * (Win + 2 * padw));
    }

    if (padh > 0 || padw > 0) {
      # Unpad image gradient
      dimg = util.unpad_image(dimg, Hin, Win, padh, padw);  # shape (C, (Hin+2*padh)*(Win+2*padw))
    }
    dX[n,] = reshape(dimg, 1, C * Hin * Win);
                      print("blubb");

  }
#dX = fill(1, 1, C*Hin*Win);
return dX;
}
