

def m_multiLogReg (X:matrix<f64>, Y:matrix<f64>, icpt:si64 /*= 2*/, tol:f64 /*= 0.000001*/, reg:f64 /*= 1.0*/, maxi:si64 /*= 100*/, maxii:si64 /*= 20*/, is_verbose:bool /*= true*/) -> matrix<f64> {
  eta0 = 0.0001;
  eta1 = 0.25;
  eta2 = 0.75;
  sigma1 = 0.25;
  sigma2 = 0.5;
  sigma3 = 4.0;
  psi = 0.1;

  N = nrow(X);
  D = ncol(X);

if (is_verbose) {
    print("BEGIN K-MEANS SCRIPT");
  }

  # Robustness for datasets with missing values (causing NaN gradients)
  hasNaNs = sum(isNan(X)) > 0;
  if (hasNaNs) {
    if(is_verbose) {
      print("multiLogReg: matrix X contains ", 0);
      print("sum(isNan(X))", 0);
      print(" missing values, replacing with 0.");
    }
    X = replace(X, nan, 0); 
    # TODO: I am not sure if NaN is recognized as a scalar like this.
  }

  # Introduce the intercept, shift and rescale the columns of X if needed
  if (icpt == 1 || icpt == 2) {
    if (N == nrow(X)) {
      N = nrow(X);
      # TODO: This is the if statement in the orginal code, does it even do anything at all?
    }
    X = cbind(X, fill(1.0, N, 1));
    D = ncol(X);
  }

  scale_lambda = fill(1.0, D, 1);
  if (icpt == 1 || icpt == 2) {
    scale_lambda[D - 1, 0] = [0.0];
  }

  rowSums_X_sq = [0.0];
  scale_X = 0.0;
  shift_X = 0.0;

  if (icpt == 2) {
    avg_X_cols = t(sum(X, 1)) / N;
    var_X_cols = (t(sum(X ^ 2, 1)) - N * (avg_X_cols ^ 2)) / (N - 1);
    is_unsafe = var_X_cols <= 0;
    scale_X = 1.0 / sqrt(var_X_cols * (1 - is_unsafe) + is_unsafe);
    scale_X[D - 1, 0] = [1.0];
    shift_X = -avg_X_cols * scale_X;
    shift_X[D - 1, 0] = [0.0];
    rowSums_X_sq = (X ^ 2) @ (scale_X ^ 2) + X @ (2 * scale_X * shift_X) + sum(shift_X ^ 2);
  } else {
    scale_X = fill(1.0, D, 1);
    shift_X = fill(0.0, D, 1);
    rowSums_X_sq = [sum(X ^ 2)];
  }

  # Convert "Y" into indicator matrix:
  max_y = aggMax(Y);

  if (aggMin(Y) <= 0) {
  # Category labels "0", "-1" etc, are converted into the largest label
    Y = Y <= 0 ? max_y + 1 : Y;
    max_y = max_y + 1;
  }
  Y = ctable(seq(1.0, N, 1.0) - 1, Y - 1, N, max_y);
  K = ncol(Y) - 1;


  lambda = (scale_lambda @ fill(1.0, 1, K)) * reg;
  delta = 0.5 * sqrt(D) / aggMax(sqrt(rowSums_X_sq)); # TODO: Delta different than in systemds?

  B = fill(0.0, D, K);

  P = fill(1.0, N, K+1);
  P = P / (K + 1);

  obj =  N * ln(K + 1);

  Grad = t(X) @ (P[, 1:K+1] - Y[, 1:K+1]);
  if (icpt == 2) {
    Grad = diagMatrix(scale_X) @ Grad + shift_X @ Grad[D-1,];
  }

  Grad =  Grad + lambda * B;
  norm_Grad = sqrt(sum(Grad ^ 2));
  norm_Grad_initial = norm_Grad;

  if (maxii == 0) {
    maxii = D * K;
  }

  iter = 1;

  # boolean for convergence check
  converge = (norm_Grad < tol) || (iter > maxi);
  if(is_verbose) {
    print("-- Initially:  Objective = " + obj + ",  Gradient Norm = " + norm_Grad + ",  Trust Delta = " + delta);
  }

  while (converge != as.ui64(1)) {
    # Solve trust region sub-problem
    S = fill(0.0, D, K);
    R = -Grad;
    V = R;
    delta2 = delta ^ 2;
    inneriter = 1;
    norm_R2 = sum(R ^ 2);
    innverconverge = sqrt(norm_R2) <= (psi * norm_Grad); # TODO: Why is this a double and cant even be converted to bool?
    is_trust_bounday_reached = 0;

    P_1K = P[,1:K+1];

    while(innverconverge != 1.0) {
      ssX_V = [0.0];
      if (icpt == 2) {
        ssX_V = diagMatrix(scale_X) @ V;
        ssX_V[D-1,] = ssX_V[D-1,] + t(shift_X) @ V;
      } else {
        ssX_V = V;
      }

      Q = P_1K * (X @ ssX_V);
      HV = t(X) @ (Q - P_1K * (sum(Q, 0) @ fill(1, 1, K)));

      if (icpt == 2) {
        HV = diagMatrix(scale_X) @ HV + shift_X @ HV[D-1,];
      }

      HV = HV + lambda * V;
      alpha = norm_R2 / sum(V * HV);
      Snew = S + alpha * V;
      norm_Snew2 = sum(Snew ^ 2);
      if (norm_Snew2 <= delta2) {
        S = Snew;
        R = R - alpha * HV;
        old_norm_R2 = norm_R2;
        norm_R2 = sum(R ^ 2);
        V = R + (norm_R2 / old_norm_R2) * V;
        innerconverge = as.f64(sqrt(norm_R2) <= psi * norm_Grad);
      } else {
        is_trust_boundary_reached = 1;
        print("TEST");
        sv = sum(S * V);
        v2 = sum(V ^ 2);
        s2 = sum(S ^ 2);
        rad = sqrt(sv ^ 2 + v2 * (delta2 - s2));
        if (sv >= 0) {
          alpha = (delta2 - s2) / (sv + rad);
        } else{ 
          alpha = (rad - sv) / v2;
        }
        S = S + alpha * V;
        R = R - alpha * HV;
      }
      inneriter = inneriter + 1;
      innverconverge = innverconverge || (inneriter > maxii);
    }
    print("TEST");


    converge = as.ui64(1);
  }

  return X;
}

