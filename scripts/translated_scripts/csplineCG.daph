def truncCG(X:matrix<f64>, by:si64, dir:str) -> matrix<f64> {
  r = as.si64(nrow(X));
  c = as.si64(ncol(X));
  
  if (by > r) {
    print("can't pop matrix more than number of rows");
    return [0.0];
  }
  
  Y = fill(as.f64(0.0), r - by, c);
  
  if (r != by) {
    
    if (dir == "up") {
      Y[0:r-by, ] = X[1+by - 1:r, ];
    } else {
      
      if (dir == "down") {
        Y[0:r-by, ] = as.matrix<f64>(X[0:r-by, ]);
      } else {
        print("truncCG unsupported direction " + dir);
        return [0.0];
      }
      
    }
    
  }
  
  return as.matrix<f64>(Y);
}

def CGSolver(A:matrix<f64>, b:matrix<f64>, max_iteration:si64, tolerance:f64) -> matrix<f64> {
  n = as.si64(nrow(A));
  
  if (max_iteration < 0) {
    max_iteration = as.si64(n);
  }
  
  
  if (tolerance < 0) {
    tolerance = as.f64(0.000001);
  }
  
  x = fill(as.f64(0), n, 1);
  i = as.si64(0);
  r = (0.0 - t(A)) @ b;
  p = (0.0 - r);
  norm_r2 = sum(r ^ 2);
  norm_r2_initial = norm_r2;
  norm_r2_target = norm_r2_initial * tolerance ^ 2;
  while (i < max_iteration && norm_r2 > norm_r2_target) {
    q = as.f64(t(A) @ (A @ p));
    a = as.f64(norm_r2 / sum(p * q));
    x = as.matrix<f64>(x + a * p);
    r = as.matrix<f64>(r + a * q);
    old_norm_r2 = norm_r2;
    norm_r2 = sum(r ^ 2);
    p = as.matrix<f64>((0.0 - r) + (norm_r2 / old_norm_r2) * p);
    i = as.si64(i + 1);
  }
  
  if (i >= max_iteration) {
    print("Warning: the maximum number of iterations has been reached.");
  }
  
  return as.matrix<f64>(x);
}

def resizeCG(X:matrix<f64>, rby:si64, cby:si64, dir:str) -> matrix<f64> {
  r = as.si64(nrow(X));
  c = as.si64(ncol(X));
  rn = r + rby;
  cn = c + cby;
  Y = fill(as.f64(0.0), rn, cn);
  
  if (dir == "tr") {
    Y[1+rby - 1:rn, 0:c] = X;
  } else {
    
    if (dir == "bl") {
      Y[0:r, 1+cby - 1:cn] = X;
    } else {
      
      if (dir == "tl") {
        Y[1+rby - 1:rn, 1+cby - 1:cn] = X;
      } else {
        
        if (dir == "br") {
          Y[0:r, 0:c] = X;
        } else {
          print("Unknown direction dir => " + dir);
          return [0.0];
        }
        
      }
      
    }
    
  }
  
  return as.matrix<f64>(Y);
}

def calcKnotsDerivKsCG(X:matrix<f64>, Y:matrix<f64>, max_iteration:si64, tolerance:f64) -> matrix<f64> {
  nx = as.si64(nrow(X));
  ny = as.si64(nrow(Y));
  
  if (nx != ny) {
    print("X and Y vectors are of different size");
    return [0.0];
  }
  
  Xu = truncCG(as.matrix<f64>(X), as.si64(1), as.str("up"));
  Xd = truncCG(as.matrix<f64>(X), as.si64(1), as.str("down"));
  Bx = 1 / (Xu - Xd);
  Bxd = resizeCG(as.matrix<f64>(Bx), as.si64(1), as.si64(0), as.str("tr"));
  Bxu = resizeCG(as.matrix<f64>(Bx), as.si64(1), as.si64(0), as.str("br"));
  Dx = 2 * (Bxd + Bxu);
  MDx = diagMatrix(Dx);
  MBx = diagMatrix(Bx);
  MUx = resizeCG(as.matrix<f64>(MBx), as.si64(1), as.si64(1), as.str("bl"));
  MLx = resizeCG(as.matrix<f64>(MBx), as.si64(1), as.si64(1), as.str("tr"));
  A = MUx + MDx + MLx;
  Yu = truncCG(as.matrix<f64>(Y), as.si64(1), as.str("up"));
  Yd = truncCG(as.matrix<f64>(Y), as.si64(1), as.str("down"));
  By = (Yu - Yd) / (Bx * Bx);
  By1 = resizeCG(as.matrix<f64>(By), as.si64(1), as.si64(0), as.str("tr"));
  By2 = resizeCG(as.matrix<f64>(By), as.si64(1), as.si64(0), as.str("br"));
  b = 3 * (By1 + By2);
  K = CGSolver(as.matrix<f64>(A), as.matrix<f64>(b), as.si64(max_iteration), as.f64(tolerance));
  return as.matrix<f64>(K);
}

def interpSplineCG(x:f64, X:matrix<f64>, Y:matrix<f64>, K:matrix<f64>) -> f64 {
  i = as.si64(as.si64(nrow(X)) - sum(X >= x) + 1);
  t = (x - X[i-1 - 1, 0]) / (X[i - 1, 0] - X[i-1 - 1, 0]);
  a = K[i-1 - 1, 0] * (X[i - 1, 0] - X[i-1 - 1, 0]) - (Y[i - 1, 0] - Y[i-1 - 1, 0]);
  b = as.matrix<f64>((0.0 - K[i - 1, 0]) * (X[i - 1, 0] - X[i-1 - 1, 0]) + (Y[i - 1, 0] - Y[i-1 - 1, 0]));
  qm = (1 - t) * Y[i-1 - 1, 0] + t * Y[i - 1, 0] + t * (1 - t) * (a * (1 - t) + b * t);
  q = as.scalar(as.f64(qm));
  return as.f64(q);
}

def m_csplineCG(X:matrix<f64>, Y:matrix<f64>, inp_x:f64, tol:f64 /*= 0.000001*/, maxi:si64 /*= 0*/) -> matrix<f64>, matrix<f64> {
  K = calcKnotsDerivKsCG(as.matrix<f64>(X), as.matrix<f64>(Y), as.si64(maxi), as.f64(tol));
  y = interpSplineCG(as.f64(inp_x), as.matrix<f64>(X), as.matrix<f64>(Y), as.matrix<f64>(K));
  pred_Y = fill(as.f64(y), 1, 1);
  return as.matrix<f64>(pred_Y), as.matrix<f64>(K);
}

